{% extends "base.html" %}
{% load static %}

{% block title %}AR Bets{% endblock %}

{% block content %}
<div class="ar-canvas-wrap">
	<canvas id="ar-canvas"></canvas>
</div>
<button type="button" id="btn-spawn" class="btn btn-primary" style="margin-top: 12px;">Ставка</button>
<div style="margin-top: 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
	<label for="user-answer">Ваш ответ:</label>
	<input type="number" id="user-answer" min="0" step="1" placeholder="Число" style="width: 100px; padding: 6px 8px;">
	<button type="button" id="btn-check" class="btn btn-secondary">Проверить</button>
</div>
<p id="answer-display" style="margin-top: 10px; font-size: 1.1rem; font-weight: 600;"></p>
<script>window.CYLINDER_TEXTURE_URL = "{% static 'CHIP_Test_2024/chip.png' %}";</script>
<script type="importmap">
{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"}}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const canvas = document.getElementById('ar-canvas');
if (!canvas) throw new Error('canvas not found');

var containerW = canvas.parentElement.clientWidth || 480;
var containerH = canvas.parentElement.clientHeight || Math.min(640, Math.floor(containerW * 0.75));
if (containerW < 100) containerW = 640;
if (containerH < 100) containerH = 360;
var w = containerW;
var h = containerH;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a1a);

const camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 1000);
camera.position.set(12.3, 10, 25);
camera.lookAt(12.3, 20.3, 0.175);
camera.rotateZ(Math.PI / 2);

const controls = new OrbitControls(camera, canvas);
controls.target.set(12.3, 15.3, 0.175);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(w, h);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(20, 25, 20);
scene.add(dir);

const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
const blueMat = new THREE.MeshStandardMaterial({ color: 0x2563eb });
const cellW = 8, cellH = 10;
const gap = 0.3;
const edge = 0.15;
const cornerScale = 0.3;

function makeNumberTexture(num, color) {
	const size = 768;
	const canvas = document.createElement('canvas');
	canvas.width = size;
	canvas.height = size;
	const ctx = canvas.getContext('2d');
	ctx.fillStyle = color || '#ffffff';
	ctx.font = 'bold 576px sans-serif';
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	ctx.fillText(String(num), size / 2, size / 2);
	const tex = new THREE.CanvasTexture(canvas);
	tex.needsUpdate = true;
	return tex;
}

var labelNumbers = [1, 4, 7, 2, 5, 8, 3, 6, 9];

function addCell(cx, cy, cellIndex) {
	const number5 = new THREE.Mesh(new THREE.PlaneGeometry(cellW, cellH), blueMat);
	number5.name = 'number 5';
	number5.position.set(cx, cy, 0);
	scene.add(number5);

	const num = labelNumbers[cellIndex];
	const isRed = [1, 3, 5, 7, 9].indexOf(num) !== -1;
	const labelColor = isRed ? '#c00' : '#000';
	const labelPlane = new THREE.Mesh(
		new THREE.PlaneGeometry(7.2, 7.2),
		new THREE.MeshBasicMaterial({
			map: makeNumberTexture(num, labelColor),
			transparent: true,
			side: THREE.DoubleSide
		})
	);
	labelPlane.position.set(cx, cy, 0.02);
	labelPlane.rotation.z = Math.PI / 2;
	labelPlane.name = 'label ' + num;
	scene.add(labelPlane);
}

const cx0 = cellW / 2, cx1 = cellW + gap + cellW / 2, cx2 = cellW + gap + cellW + gap + cellW / 2;
const cy0 = cellH / 2, cy1 = cellH + gap + cellH / 2, cy2 = cellH + gap + cellH + gap + cellH / 2;
const centers = [
	[cx0, cy0], [cx1, cy0], [cx2, cy0],
	[cx0, cy1], [cx1, cy1], [cx2, cy1],
	[cx0, cy2], [cx1, cy2], [cx2, cy2]
];
centers.forEach(function (c, i) { addCell(c[0], c[1], i); });

const centerCell = [cx1, cy1];
const halfW = cellW / 2, halfH = cellH / 2;
const splitCenter = gap / 2;
const axesCenter = new THREE.AxesHelper(2);
axesCenter.position.set(centerCell[0], centerCell[1], 0.1);
axesCenter.visible = false;
scene.add(axesCenter);

const axesLeft = new THREE.AxesHelper(1.2);
axesLeft.position.set(cx1 - halfW - splitCenter, cy1, 0.1);
axesLeft.visible = false;
scene.add(axesLeft);
const axesRight = new THREE.AxesHelper(1.2);
axesRight.position.set(cx1 + halfW + splitCenter, cy1, 0.1);
axesRight.visible = false;
scene.add(axesRight);
const axesTop = new THREE.AxesHelper(1.2);
axesTop.position.set(cx1, cy1 + halfH + splitCenter, 0.1);
axesTop.visible = false;
scene.add(axesTop);
const axesBottom = new THREE.AxesHelper(1.2);
axesBottom.position.set(cx1, cy1 - halfH - splitCenter, 0.1);
axesBottom.visible = false;
scene.add(axesBottom);

const cornerTL = new THREE.AxesHelper(1.2);
cornerTL.position.set(cx1 - halfW - splitCenter, cy1 + halfH + splitCenter, 0.1);
cornerTL.visible = false;
scene.add(cornerTL);
const cornerTR = new THREE.AxesHelper(1.2);
cornerTR.position.set(cx1 + halfW + splitCenter, cy1 + halfH + splitCenter, 0.1);
cornerTR.visible = false;
scene.add(cornerTR);
const cornerBL = new THREE.AxesHelper(1.2);
cornerBL.position.set(cx1 - halfW - splitCenter, cy1 - halfH - splitCenter, 0.1);
cornerBL.visible = false;
scene.add(cornerBL);
const cornerBR = new THREE.AxesHelper(1.2);
cornerBR.position.set(cx1 + halfW + splitCenter, cy1 - halfH - splitCenter, 0.1);
cornerBR.visible = false;
scene.add(cornerBR);

const axisAbove8 = new THREE.AxesHelper(1.2);
axisAbove8.position.set(cx1, cy2 + halfH + splitCenter, 0.1);
axisAbove8.visible = false;
scene.add(axisAbove8);
const axisAbove8Left = new THREE.AxesHelper(1.2);
axisAbove8Left.position.set(cx1 - halfW - splitCenter, cy2 + halfH + splitCenter, 0.1);
axisAbove8Left.visible = false;
scene.add(axisAbove8Left);
const axisAbove8Right = new THREE.AxesHelper(1.2);
axisAbove8Right.position.set(cx1 + halfW + splitCenter, cy2 + halfH + splitCenter, 0.1);
axisAbove8Right.visible = false;
scene.add(axisAbove8Right);

const gridLeft = -edge;
const gridRight = cellW + gap + cellW + gap + cellW + edge;
const gridBottom = -edge;
const gridTop = cellH + gap + cellH + gap + cellH + edge;
const vertLineH = gridTop - gridBottom;
const horzLineW = gridRight - gridLeft;

const vertX = [gridLeft, cellW + gap / 2, cellW + gap + cellW + gap / 2, gridRight];
vertX.forEach(function (x) {
	const line = new THREE.Mesh(new THREE.PlaneGeometry(gap, vertLineH), whiteMat);
	line.name = 'split';
	line.position.set(x, (gridTop + gridBottom) / 2, 0);
	scene.add(line);
});

const horzY = [gridBottom, cellH + gap / 2, cellH + gap + cellH + gap / 2, gridTop];
horzY.forEach(function (y) {
	const line = new THREE.Mesh(new THREE.PlaneGeometry(horzLineW, gap), whiteMat);
	line.name = 'split';
	line.position.set((gridLeft + gridRight) / 2, y, 0);
	scene.add(line);
});

vertX.forEach(function (x) {
	horzY.forEach(function (y) {
		const corner = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), whiteMat);
		corner.name = 'corner';
		corner.position.set(x, y, 0);
		corner.scale.set(cornerScale, cornerScale, 1);
		scene.add(corner);
	});
});

const spawnZ = 0.175;
const spawnZ2 = spawnZ + 0.35;
const spawnZ3 = spawnZ + 0.7;
const spawnZ4 = spawnZ + 1.05;
const spawnPoints = [
	[centerCell[0], centerCell[1]],
	[cx1 - halfW - splitCenter, cy1],
	[cx1 + halfW + splitCenter, cy1],
	[cx1, cy1 + halfH + splitCenter],
	[cx1, cy1 - halfH - splitCenter],
	[cx1 - halfW - splitCenter, cy1 + halfH + splitCenter],
	[cx1 + halfW + splitCenter, cy1 + halfH + splitCenter],
	[cx1 - halfW - splitCenter, cy1 - halfH - splitCenter],
	[cx1 + halfW + splitCenter, cy1 - halfH - splitCenter],
	[cx1, cy2 + halfH + splitCenter],
	[cx1 - halfW - splitCenter, cy2 + halfH + splitCenter],
	[cx1 + halfW + splitCenter, cy2 + halfH + splitCenter]
];

const chipsGroup = new THREE.Group();
chipsGroup.name = 'chips';
scene.add(chipsGroup);

let correctAnswer = null;

document.getElementById('btn-spawn').addEventListener('click', function () {
	correctAnswer = null;
	document.getElementById('answer-display').textContent = '';
	document.getElementById('user-answer').value = '';
	document.getElementById('user-answer').focus();
	while (chipsGroup.children.length) {
		chipsGroup.remove(chipsGroup.children[0]);
	}
	const cylGeom = new THREE.CylinderGeometry(1.5, 1.5, 0.35, 32);
	const loader = new THREE.TextureLoader();
	const texUrl = window.CYLINDER_TEXTURE_URL || '';
	function addCylinder(material, x, y, z, rotZ) {
		if (rotZ !== undefined) {
			const group = new THREE.Group();
			group.position.set(x, y, z);
			group.rotation.z = rotZ;
			const cyl = new THREE.Mesh(cylGeom, material);
			cyl.rotation.x = -Math.PI / 2;
			group.add(cyl);
			chipsGroup.add(group);
		} else {
			const cyl = new THREE.Mesh(cylGeom, material);
			cyl.position.set(x, y, z);
			cyl.rotation.x = -Math.PI / 2;
			chipsGroup.add(cyl);
		}
	}
	function runSpawns(material) {
		const chipCounts = new Array(12).fill(0);
		for (let i = 0; i < 12; i++) {
			const r = Math.random();
			const count = r < 0.25 ? 1 : r < 0.5 ? 2 : r < 0.75 ? 3 : 4;
			chipCounts[i] = count;
			const x = spawnPoints[i][0], y = spawnPoints[i][1];
			addCylinder(material, x, y, spawnZ);
			if (count >= 2) {
				const rotZ = (Math.random() - 0.5) * 0.4;
				addCylinder(material, x, y + 0.6, spawnZ2, rotZ);
			}
			if (count >= 3) {
				const rotZ = (Math.random() - 0.5) * 0.4;
				addCylinder(material, x, y + 1.2, spawnZ3, rotZ);
			}
			if (count >= 4) {
				const rotZ = (Math.random() - 0.5) * 0.4;
				addCylinder(material, x, y + 1.8, spawnZ4, rotZ);
			}
		}
		const numChips = chipCounts[0];
		const splitChips = chipCounts[1] + chipCounts[2] + chipCounts[3] + chipCounts[4];
		const cornerChips = chipCounts[5] + chipCounts[6] + chipCounts[7] + chipCounts[8];
		const streetChips = chipCounts[9];
		const sixlineChips = chipCounts[10] + chipCounts[11];
		correctAnswer = numChips * 35 + splitChips * 17 + cornerChips * 8 + streetChips * 11 + sixlineChips * 5;
		document.getElementById('answer-display').textContent = 'Введите ответ и нажмите «Проверить».';
	}
	if (texUrl) {
		loader.load(texUrl, function (tex) {
			tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
			tex.colorSpace = THREE.SRGBColorSpace;
			runSpawns(new THREE.MeshBasicMaterial({ map: tex }));
		}, undefined, function () {
			runSpawns(new THREE.MeshStandardMaterial({ color: 0xdc2626 }));
		});
	} else {
		runSpawns(new THREE.MeshStandardMaterial({ color: 0xdc2626 }));
	}
});

function doCheck() {
	const el = document.getElementById('answer-display');
	const input = document.getElementById('user-answer');
	const userVal = input.value.trim() === '' ? NaN : parseInt(input.value, 10);
	if (correctAnswer === null) {
		el.textContent = 'Сначала нажмите «Ставка».';
		el.style.color = '';
		return;
	}
	if (!Number.isInteger(userVal) || userVal < 0) {
		el.textContent = 'Введите целое неотрицательное число.';
		el.style.color = '';
		return;
	}
	if (userVal === correctAnswer) {
		el.textContent = 'Верно!';
		el.style.color = 'green';
	} else {
		el.textContent = 'Неверно. Правильный ответ: ' + correctAnswer;
		el.style.color = 'crimson';
	}
}
document.getElementById('btn-check').addEventListener('click', doCheck);
document.getElementById('user-answer').addEventListener('keydown', function (e) {
	if (e.key === 'Enter') doCheck();
});

function animate() {
	requestAnimationFrame(animate);
	controls.update();
	renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', function () {
	containerW = canvas.parentElement.clientWidth || 640;
	containerH = canvas.parentElement.clientHeight || Math.min(480, Math.floor(containerW * 0.75));
	if (containerW < 100) containerW = 640;
	if (containerH < 100) containerH = 360;
	w = containerW;
	h = containerH;
	camera.aspect = w / h;
	camera.updateProjectionMatrix();
	renderer.setSize(w, h);
});
</script>
{% endblock %}
